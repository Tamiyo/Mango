#########################################
##   Extended Construction Statement   ##
#########################################

## Required by the parser, the entry point.
NTS_MANGO -> NTS_STATEMENT_SUITE

####################################
##   Block Statement Definition   ##
####################################

## Block Statement for the "Main" script
NTS_STATEMENT_SUITE -> NTS_STATEMENT_LIST
{
    let statement_list = node_stack.pop().unwrap();
    let node = NodeStatementSuite { statement_list: statement_list };
    node_stack.push(Box::new(node));
}
## Block Statement to be used inside Functions / Methods / Procedures
NTS_STATEMENT_SUITE_FUNCTION -> NTS_STATEMENT_LIST_FUNCTION
{
    let statement_limited = node_stack.pop().unwrap();
    let node = NodeStatementListFunction { statement_limited: statement_limited };
    node_stack.push(Box::new(node));
}

## Block Statement to be used inside Classes
NTS_STATEMENT_SUITE_CLASS -> NTS_STATEMENT_LIST_CLASS
{
    let statement_list_class = node_stack.pop().unwrap();
    let node = NodeStatementSuiteClass { statement_list_class: statement_list_class };
    node_stack.push(Box::new(node));
}

########################################
##   Recursive Statement Definition   ##
########################################

## Recursive Statement for the "Main" script
NTS_STATEMENT_LIST -> NTS_STATEMENT TS_NEWLINE NTS_STATEMENT_LIST
{
    let statement_list = node_stack.pop().unwrap();
    let statement = node_stack.pop().unwrap();
    let node = NodeStatementListRecursive { statement: statement, statement_list: statement_list };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_LIST -> NTS_STATEMENT
{
    let statement = node_stack.pop().unwrap();
    let node = NodeStatementList { statement: statement };
    node_stack.push(Box::new(node));
}

## Recursive Statement for the "Method / Function / Procedure"
NTS_STATEMENT_LIST_FUNCTION -> NTS_STATEMENT_LIMITED NTS_STATEMENT_LIST_FUNCTION
{
    let statement_list_function = node_stack.pop().unwrap();
    let statement_limited = node_stack.pop().unwrap();
    let node = NodeStatementListFunctionRecursive { statement_limited: statement_limited, statement_list_function: statement_list_function };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_LIST_FUNCTION -> NTS_STATEMENT_LIMITED
{
    let statement_limited = node_stack.pop().unwrap();
    let node = NodeStatementListFunction { statement_limited: statement_limited };
    node_stack.push(Box::new(node));
}

## Recursive Statement for the "Class"
NTS_STATEMENT_LIST_CLASS -> NTS_STATEMENT_RESTRICTED NTS_STATEMENT_LIST_CLASS
{
    let statement_list_class = node_stack.pop().unwrap();
    let statement_restricted = node_stack.pop().unwrap();
    let node = NodeStatementListClassRecursive { statement_restricted: statement_restricted, statement_list_class: statement_list_class };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_LIST_CLASS -> NTS_STATEMENT_RESTRICTED
{
    let statement_restricted = node_stack.pop().unwrap();
    let node = NodeStatementListClass { statement_restricted: statement_restricted };
    node_stack.push(Box::new(node));
}

######################################
##  Wrapper Statement Definitions   ##
######################################

## Statement Wrapper for "Any" statement
NTS_STATEMENT -> NTS_STATEMENT_SIMPLE
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatement { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT -> NTS_STATEMENT_COMPLEX
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatement { statement_x: statement_x };
    node_stack.push(Box::new(node));
}
NTS_STATEMENT -> NTS_STATEMENT_FUNCTION
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatement { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT -> NTS_STATEMENT_CLASS
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatement { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

## Statement Wrapper for "Method / Function / Procedure"
NTS_STATEMENT_LIMITED -> NTS_STATEMENT_SIMPLE
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementLimited { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_LIMITED -> NTS_STATEMENT_COMPLEX
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementLimited { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

## Statement Wrapper for "Class"
NTS_STATEMENT_RESTRICTED -> NTS_STATEMENT_FUNCTION
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementRestricted { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

###############################
##   Statement Definitions   ##
###############################

## Simple statements that can be included anywhere without a problem
NTS_STATEMENT_SIMPLE -> NTS_STATEMENT_EXPRESSION
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementSimple { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_SIMPLE -> NTS_STATEMENT_ASSIGNMENT
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementSimple { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_SIMPLE -> NTS_STATEMENT_CONDITIONAL
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementSimple { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

## Complex statements that are more involved with their logic
NTS_STATEMENT_COMPLEX -> NTS_STATEMENT_LOOP
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementComplex { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

## Function Definition
NTS_STATEMENT_FUNCTION -> TS_AT TS_IDENTIFIER TS_COLON NTS_FUNCTION_PARAMS TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
{
    let statement_suite_function = node_stack.pop().unwrap();
    let function_params = node_stack.pop().unwrap();
    let identifier = node_stack.pop().unwrap();
    let node = NodeStatementFunction { identifier: identifier, function_params: function_params, statement_suite_function: statement_suite_function };
    node_stack.push(Box::new(node));
}

## Recursive Function Parameters
NTS_FUNCTION_PARAMS -> NTS_FUNCTION_PARAMS TS_COMMA NTS_STATEMENT_EXPRESSION
{
    let identifier = node_stack.pop().unwrap();
    let function_params = node_stack.pop().unwrap();
    let node = NodeFunctionParamsRecursive { function_params: function_params, identifier: identifier };
    node_stack.push(Box::new(node));
}

NTS_FUNCTION_PARAMS -> NTS_STATEMENT_EXPRESSION
{
    let identifier = node_stack.pop().unwrap();
    let node = NodeFunctionParams { identifier: identifier };
    node_stack.push(Box::new(node));
}

## Class Definition
NTS_STATEMENT_CLASS -> TS_AT TS_IDENTIFIER TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_CLASS TS_RIGHT_CURLY_BRACE
{
    let statement_suite_class = node_stack.pop().unwrap();
    let identifier = node_stack.pop().unwrap();
    let node = NodeStatementClass { identifier: identifier, statement_suite_class: statement_suite_class };
    node_stack.push(Box::new(node));
}

###############################
##   Expression Statements   ##
###############################

## Expressions for Addition and Subtraction without right recursion
NTS_STATEMENT_EXPRESSION -> NTS_STATEMENT_EXPRESSION_2 NTS_STATEMENT_EXPRESSION_P
{
    let statement_expression_p = node_stack.pop().unwrap();
    let statement_expression_2 = node_stack.pop().unwrap();
    let node = NodeStatementExpressionRecursive { statement_expression_2: statement_expression_2, statement_expression_p: statement_expression_p };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION -> NTS_STATEMENT_EXPRESSION_2
{
    let statement_expression_2 = node_stack.pop().unwrap();
    let node = NodeStatementExpression { statement_expression_2: statement_expression_2 };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_P -> TS_ADD NTS_STATEMENT_EXPRESSION
{
    let statement_expression = node_stack.pop().unwrap();
    let node = NodeStatementExpressionP { statement_expression: statement_expression, operator: TokenType::Add };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_P -> TS_SUBTRACT NTS_STATEMENT_EXPRESSION
{
    let statement_expression = node_stack.pop().unwrap();
    let node = NodeStatementExpressionP { statement_expression: statement_expression, operator: TokenType::Subtract };
    node_stack.push(Box::new(node));
}

## Expressions for Multiplication, Division, and Modulo without right recursion
NTS_STATEMENT_EXPRESSION_2 -> NTS_STATEMENT_EXPRESSION_3 NTS_STATEMENT_EXPRESSION_2P
{
    let statement_expression_2p = node_stack.pop().unwrap();
    let statement_expression_3 = node_stack.pop().unwrap();
    let node = NodeStatementExpression2Recursive { statement_expression_3: statement_expression_3, statement_expression_2p: statement_expression_2p };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_2 -> NTS_STATEMENT_EXPRESSION_3
{
    let statement_expression_3 = node_stack.pop().unwrap();
    let node = NodeStatementExpression2 { statement_expression_3: statement_expression_3 };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_2P -> TS_MULTIPLY NTS_STATEMENT_EXPRESSION_2
{
    let statement_expression_2 = node_stack.pop().unwrap();
    let node = NodeStatementExpression2p { statement_expression_2: statement_expression_2, operator: TokenType::Multiply };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_2P -> TS_DIVIDE NTS_STATEMENT_EXPRESSION_2
{
    let statement_expression_2 = node_stack.pop().unwrap();
    let node = NodeStatementExpression2p { statement_expression_2: statement_expression_2, operator: TokenType::Divide };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_2P -> TS_MODULO NTS_STATEMENT_EXPRESSION_2
{
    let statement_expression_2 = node_stack.pop().unwrap();
    let node = NodeStatementExpression2p { statement_expression_2: statement_expression_2, operator: TokenType::Modulo };
    node_stack.push(Box::new(node));
}

## Expressions for negative terms, parenthesized terms, and an ending point without right recursion
NTS_STATEMENT_EXPRESSION_3 -> TS_TERM
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementExpression3 { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_3 -> TS_IDENTIFIER
{
    let statement_x = node_stack.pop().unwrap();
    let node = NodeStatementExpression3 { statement_x: statement_x };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_3 -> TS_IDENTIFIER TS_COLON NTS_FUNCTION_PARAMS
{
    let function_params = node_stack.pop().unwrap();
    let identifier = node_stack.pop().unwrap();
    let node = NodeStatementExpression3Function { identifier: identifier, function_params: function_params };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_3 -> TS_LEFT_PARENTHESIS NTS_STATEMENT_EXPRESSION TS_RIGHT_PARENTHESIS
{
    let statement_expression = node_stack.pop().unwrap();
    let node = NodeStatementExpression3Paren { statement_expression: statement_expression };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_EXPRESSION_3 -> TS_SUBTRACT NTS_STATEMENT_EXPRESSION_3
{
    let statement_expression_3 = node_stack.pop().unwrap();
    let node = NodeStatementExpression3Negation { statement_expression_3: statement_expression_3 };
    node_stack.push(Box::new(node));
}

##############################
##   Assignment Statement   ##
##############################

## Assignment Statement for storing variables within the symbol table
NTS_STATEMENT_ASSIGNMENT -> TS_IDENTIFIER TS_EQUALS NTS_STATEMENT_EXPRESSION
{
    let statement_expression = node_stack.pop().unwrap();
    let identifier = node_stack.pop().unwrap();
    let node = NodeStatementAssignment { identifier: identifier, statement_expression: statement_expression };
    node_stack.push(Box::new(node));
}

################################
##   Conditional Statements   ##
################################

## If Conditional Statement
NTS_STATEMENT_CONDITIONAL -> TS_IF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
{
    let statement_suite_function = node_stack.pop().unwrap();
    let conditional_expression = node_stack.pop().unwrap();
    let node = NodeStatementConditional { conditional_expression: conditional_expression, statement_suite_function: statement_suite_function };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_CONDITIONAL -> TS_IF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE NTS_STATEMENT_CONDITIONAL_2
{
    let statement_conditional_2 = node_stack.pop().unwrap();
    let statement_suite_function = node_stack.pop().unwrap();
    let conditional_expression = node_stack.pop().unwrap();
    let node = NodeStatementConditionalW2 { conditional_expression: conditional_expression, statement_suite_function: statement_suite_function, statement_conditional_2: statement_conditional_2 };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_CONDITIONAL -> TS_IF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE NTS_STATEMENT_CONDITIONAL_3
{
    let statement_conditional_3 = node_stack.pop().unwrap();
    let statement_suite_function = node_stack.pop().unwrap();
    let conditional_expression = node_stack.pop().unwrap();
    let node = NodeStatementConditionalW3 { conditional_expression: conditional_expression, statement_suite_function: statement_suite_function, statement_conditional_3: statement_conditional_3 };
    node_stack.push(Box::new(node));
}

## Elif Conditional Statement
NTS_STATEMENT_CONDITIONAL_2 -> NTS_STATEMENT_CONDITIONAL_2 TS_ELIF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
{
    let statement_suite_function = node_stack.pop().unwrap();
    let conditional_expression = node_stack.pop().unwrap();
    let statement_conditional_2 = node_stack.pop().unwrap();
    let node = NodeStatementConditional2Recursive { statement_conditional_2: statement_conditional_2, conditional_expression: conditional_expression, statement_suite_function: statement_suite_function };
    node_stack.push(Box::new(node));
}

NTS_STATEMENT_CONDITIONAL_2 -> TS_ELIF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE NTS_STATEMENT_CONDITIONAL_3
{
    let statement_conditional_3 = node_stack.pop().unwrap();
    let statement_suite_function = node_stack.pop().unwrap();
    let conditional_expression = node_stack.pop().unwrap();
    let node = NodeStatementConditional2 { conditional_expression: conditional_expression, statement_suite_function: statement_suite_function, statement_conditional_3: statement_conditional_3 };
    node_stack.push(Box::new(node));
}

## Else Conditional Statement
NTS_STATEMENT_CONDITIONAL_3 -> TS_ELSE TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
{
    let statement_suite_function = node_stack.pop().unwrap();
    let node = NodeStatementConditional3 { statement_suite_function: statement_suite_function };
    node_stack.push(Box::new(node));
}

################################
##   Conditional Expression   ##
################################

## Conditional Statement
NTS_CONDITIONAL_EXPRESSION -> NTS_STATEMENT_EXPRESSION NTS_COMPARISON_OPERATOR NTS_STATEMENT_EXPRESSION
{
    let term2 = node_stack.pop().unwrap();
    let comparison_operator = node_stack.pop().unwrap();
    let term1 = node_stack.pop().unwrap();
    let node = NodeConditionalExpression { term1: term1, comparison_operator: comparison_operator, term2: term2 };
    node_stack.push(Box::new(node));
}

NTS_CONDITIONAL_EXPRESSION -> NTS_COMPARISON_OPERATOR_UNARY NTS_STATEMENT_EXPRESSION
{
    let term = node_stack.pop().unwrap();
    let comparison_operator_unary = node_stack.pop().unwrap();
    let node = NodeConditionalExpressionUnary { comparison_operator_unary: comparison_operator_unary, term: term };
    node_stack.push(Box::new(node));
}

## Binary Operators
NTS_COMPARISON_OPERATOR -> TS_LESS_THAN
NTS_COMPARISON_OPERATOR -> TS_LESS_THAN_EQUALS
NTS_COMPARISON_OPERATOR -> TS_GREATER_THAN
NTS_COMPARISON_OPERATOR -> TS_GREATER_THAN_EQUALS
NTS_COMPARISON_OPERATOR -> TS_DOUBLE_EQUALS
NTS_COMPARISON_OPERATOR -> TS_TRIPLE_EQUALS


## Unary Operators
NTS_COMPARISON_OPERATOR_UNARY -> TS_NOT

############################
##   Looping Statements   ##
############################

## Loop wrapping construct
NTS_STATEMENT_LOOP -> NTS_STATEMENT_LOOP_FOR
NTS_STATEMENT_LOOP -> NTS_STATEMENT_LOOP_WHILE

## For Loop Constructs
# Range based or integer based from 0..X
NTS_STATEMENT_LOOP_FOR -> TS_FOR TS_IDENTIFIER TS_COLON NTS_STATEMENT_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE

# Iteration based from X..Y
NTS_STATEMENT_LOOP_FOR -> TS_FOR TS_IDENTIFIER TS_COLON NTS_STATEMENT_EXPRESSION TS_ELLIPSIS NTS_STATEMENT_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE

## While Loop Construct
NTS_STATEMENT_LOOP_WHILE -> TS_WHILE NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
