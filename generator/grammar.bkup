# Extended Construction Statement
NTS_MANGO -> NTS_STATEMENTS

# Recursive Statement Definition
NTS_STATEMENTS -> NTS_STATEMENT TS_NEWLINE

# Defining Statements
NTS_STATEMENT -> NTS_STATEMENT_EXPRESSION
NTS_STATEMENT -> NTS_STATEMENT_ASSIGNMENT
NTS_STATEMENT -> NTS_STATEMENT_CONDITIONAL
NTS_STATEMENT -> NTS_STATEMENT_LOOP
NTS_STATEMENT -> NTS_STATEMENT_DEFINE_FUNCTION

# Expression Statement (designed to prevent left recursion)

# if Term.type == Expression.eval().type
#   return Term.value + Expression.eval()
# elif Term.type  {can be converted to} Expression.eval().type
#   return converted(Term.value) + Expression.eval()
# elif Expression.eval().type {can be converted to} Term.type
#   return Term.value + converted(Expression.eval())
# else
#   {type mismatch error}
NTS_STATEMENT_EXPRESSION -> TS_TERM TS_OPERATOR_ADD NTS_STATEMENT_EXPRESSION


# if Term.type == Expression.eval().type
#   return Term.value - Expression.eval()
# elif Term.type  {can be converted to} Expression.eval().type
#   return converted(Term.value) - Expression.eval()
# elif Expression.eval().type {can be converted to} Term.type
#   return Term.value - converted(Expression.eval())
# else
#   {type mismatch error}
NTS_STATEMENT_EXPRESSION -> TS_TERM TS_OPERATOR_SUB NTS_STATEMENT_EXPRESSION
NTS_STATEMENT_EXPRESSION -> TS_TERM
NTS_STATEMENT_EXPRESSION -> NTS_STATEMENT_EXPRESSION_2

# if Term.type == Expression.eval().type
#   return Term.value * Expression.eval()
# elif Term.type  {can be converted to} Expression.eval().type
#   return converted(Term.value) * Expression.eval()
# elif Expression.eval().type {can be converted to} Term.type
#   return Term.value * converted(Expression.eval())
# else
#   {type mismatch error}
NTS_STATEMENT_EXPRESSION_2 -> TS_TERM TS_OPERATOR_MUL NTS_STATEMENT_EXPRESSION_3

# if Term.type == Expression.eval().type
#   return Term.value / Expression.eval()
# elif Term.type  {can be converted to} Expression.eval().type
#   return converted(Term.value) / Expression.eval()
# elif Expression.eval().type {can be converted to} Term.type
#   return Term.value / converted(Expression.eval())
# else
#   {type mismatch error}
NTS_STATEMENT_EXPRESSION_2 -> TS_TERM TS_OPERATOR_DIV NTS_STATEMENT_EXPRESSION_3

# if Term.type == Expression.eval().type
#   return Term.value % Expression.eval()
# elif Term.type  {can be converted to} Expression.eval().type
#   return converted(Term.value) % Expression.eval()
# elif Expression.eval().type {can be converted to} Term.type
#   return Term.value % converted(Expression.eval())
# else
#   {type mismatch error}
NTS_STATEMENT_EXPRESSION_2 -> TS_TERM TS_OPERATOR_MODULO NTS_STATEMENT_EXPRESSION_3
NTS_STATEMENT_EXPRESSION_2 -> TS_TERM

# Assignment Statement
# symbol_table<String, Term>;

# symbol_table[Identifier] = Expression.eval();
NTS_STATEMENT_ASSIGNMENT -> TS_IDENTIFIER TS_OPERATOR_EQUALS NTS_STATEMENT_EXPRESSION

# Conditional Constructs
NTS_STATEMENT_CONDITIONAL -> TS_IF NTS_STATEMENT_CONDITIONAL_TEST TS_COLON NTS_STATEMENTS
NTS_STATEMENT_CONDITIONAL -> TS_IF NTS_STATEMENT_CONDITIONAL_TEST TS_COLON NTS_STATEMENTS NTS_STATEMENT_CONDITIONAL_ELIF

NTS_STATEMENT_CONDITIONAL_ELIF -> TS_ELIF NTS_STATEMENT_CONDITIONAL_TEST TS_COLON NTS_STATEMENTS
NTS_STATEMENT_CONDITIONAL_ELIF -> TS_ELIF NTS_STATEMENT_CONDITIONAL_TEST TS_COLON NTS_STATEMENTS NTS_STATEMENT_CONDITIONAL_ELIF
NTS_STATEMENT_CONDITIONAL_ELIF -> TS_ELIF NTS_STATEMENT_CONDITIONAL_TEST TS_COLON NTS_STATEMENTS NTS_STATEMENT_CONDITIONAL_ELSE

NTS_STATEMENT_CONDITIONAL_ELSE -> TS_ELIF NTS_STATEMENT_CONDITIONAL_TEST TS_COLON NTS_STATEMENTS

# Conditional Test Statements

# Operator Definitions
# <, <=, >, >=, ==, ===

#
# if Term.type == Expression.eval().type
#   return term1.value {compared to} term2.value
# elif Term.type  {can be converted to} Expression.eval().type
#   return converted(term1.value) {compared to} Expression.eval().value
# elif Expression.eval().type {can be converted to} Term.type
#   return term1.value {compared to} converted(Expression.eval()).value
# else
#   {type mismatch error}
NTS_STATEMENT_CONDITIONAL_TEST -> TS_TERM TS_OPERATOR_LT TS_TERM
NTS_STATEMENT_CONDITIONAL_TEST -> TS_TERM TS_OPERATOR_LTE TS_TERM
NTS_STATEMENT_CONDITIONAL_TEST -> TS_TERM TS_OPERATOR_GT TS_TERM
NTS_STATEMENT_CONDITIONAL_TEST -> TS_TERM TS_OPERATOR_GTE TS_TERM
NTS_STATEMENT_CONDITIONAL_TEST -> TS_TERM TS_OPERATOR_DOUBLE_EQUALS TS_TERM
NTS_STATEMENT_CONDITIONAL_TEST -> TS_TERM TS_OPERATOR_TRIPLE_EQUALS TS_TERM

NTS_STATEMENT_CONDITIONAL_TEST -> NTS_OPERATOR_UNARY TS_TERM
NTS_STATEMENT_CONDITIONAL_TEST -> TS_TERM

# Operator Definitions
# <, <=, >, >=, ==, ===
NTS_OPERATOR_BINARY -> TS_OPERATOR_LT
NTS_OPERATOR_BINARY -> TS_OPERATOR_LTE
NTS_OPERATOR_BINARY -> TS_OPERATOR_GT
NTS_OPERATOR_BINARY -> TS_OPERATOR_GTE
NTS_OPERATOR_BINARY -> TS_OPERATOR_DOUBLE_EQUALS
NTS_OPERATOR_BINARY -> TS_OPERATOR_TRIPLE_EQUALS

# !, ?
NTS_OPERATOR_UNARY -> TS_OPERATOR_NEG
NTS_OPERATOR_UNARY -> TS_OPERATOR_NONNULL

# Looping Constructs
# for, while
NTS_STATEMENT_LOOP -> NTS_STATEMENT_LOOP_FOR
NTS_STATEMENT_LOOP -> NTS_STATEMENT_LOOP_WHILE

NTS_STATEMENT_LOOP_FOR -> TS_FOR TS_IDENTIFIER TS_COMMA TS_TERM TS_COLON NTS_STATEMENTS
NTS_STATEMENT_LOOP_FOR -> TS_FOR TS_IDENTIFIER TS_COMMA TS_TERM TS_COMMA TS_TERM TS_COLON NTS_STATEMENTS
NTS_STATEMENT_LOOP_FOR -> TS_FOR TS_IDENTIFIER TS_COMMA TS_TERM TS_COLON NTS_STATEMENTS

NTS_STATEMENT_LOOP_WHILE -> TS_WHILE NTS_STATEMENT_CONDITIONAL_TEST TS_COLON NTS_STATEMENTS

# Function Definitions
NTS_STATEMENT_DEFINE_FUNCTION -> TS_DEFINE TS_IDENTIFIER TS_LPAREN NTS_FUNCTION_PARAMS TS_COLON
NTS_FUNCTION_PARAMS -> TS_IDENTIFIER TS_COMMA NTS_FUNCTION_PARAMS
NTS_FUNCTION_PARAMS -> TS_IDENTIFIER TS_RPAREN
NTS_FUNCTION_PARAMS -> TS_RPAREN

# Class Definitions
NTS_STATEMENT_DEFINE_CLASS -> TS_DEFINE TS_IDENTIFIER TS_COLON NTS_STATEMENTS