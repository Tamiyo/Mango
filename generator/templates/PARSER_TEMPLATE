// Parser, uses CLR parsing

#ifndef MANGO_V2_CPP_PARSER_H
#define MANGO_V2_CPP_PARSER_H

#include <string>
#include <map>
#include <vector>

#include "core.h"
#include "common.h"
#include "ast.h"

using std::map;
using std::pair;
using std::string;
using std::vector;

struct Parser {

private:
    map<pair<int, TokenType>, ActionNode> action_table;
    map<int, GotoNode> goto_table;

public:
    vector<LexerResult> token_stack;

    explicit Parser(vector<LexerResult> token_stack) {
        this->token_stack = std::move(token_stack);
    }

    void initialize() {
@@PARSE_TABLE_INSERTION@@
    }

    Node* parse() {
        initialize();

        printf("Beginning Parse...\n");

        vector<int> stack;
        stack.push_back(0);

        vector<Node*> node_stack;

        int iterator = 0;

        for (LexerResult i : token_stack) {
            cout << i.token << " | ";
        }
        cout << endl;


        LexerResult token = token_stack.at(iterator++);

        while (true) {

            for (int i : stack) {
                std::cout << i << ' ';
            }
            cout << endl;

            int state = stack.back();
            ActionNode action_node = action_table[{state, token.token_type}];

            cout << "Token: " << token.token << ", ";
            cout << "State: " << state << ", TokenType::" << token.token_type;
            cout << ", Action: " << action_node.action << " -> " << action_node.value << endl;

            if (action_node.value == 0) {
                printf("Parse Error");
                break;
            }

            if (action_node.action == ParserAction::Shift) {
                if (token.token_type == TokenType::Term) {
                    token_stack.push_back(token);
                }
                stack.push_back(action_node.value);

                if (token.token_type == TokenType::Term || token.token_type == TokenType::LessThan ||
                    token.token_type == TokenType::GreaterThan ||
                    token.token_type == TokenType::GreaterThanEquals || token.token_type == TokenType::LessThanEquals ||
                    token.token_type == TokenType::DoubleEquals ||
                    token.token_type == TokenType::TripleEquals) {
                    NodeTerm* node = new NodeTerm{token.token, token.inferred_type, token.token_type};
                    node_stack.push_back(node);
                } else if (token.token_type == TokenType::Identifier) {
                    NodeIdentifier* node = new NodeIdentifier{token.token, token.inferred_type, token.token_type};
                    node_stack.push_back(node);
                } else {}
                token = token_stack.at(iterator++);
            } else if (action_node.action == ParserAction::Reduce) {
                GotoNode goto_node = goto_table[action_node.value];
                for (int i = 0; i < goto_node.value; i++) {
                    stack.pop_back();
                }
                state = stack.back();
                ActionNode goto_action = action_table[{state, goto_node.token_type}];
                stack.push_back(goto_action.value);

                switch (action_node.value) {
@@REDUCE_STATEMENTS@@
                }
            } else if (action_node.action == ParserAction::Accept) {
                printf("Parse Accepted!\n");
                Node* t_node = node_stack.front();
                node_stack.pop_back();

                NodeMango* node = new NodeMango{t_node};
                return node;
            } else {
                printf("Parse Error!\n");
                break;
            }
        }
    }
};

#endif //MANGO_V2_CPP_PARSER_H
