use core::borrow::Borrow;
use std::collections::HashMap;
use std::ptr::null;
use std::slice::Iter;
use std::vec::Vec;
use crate::core::{ActionNode, GotoNode, LexerResult, ParserAction, PrimitiveType, TokenType};
use crate::core::TokenType::{StatementSuite, Term};
use crate::parse_tree::{Node, NodeIdentifier, NodeMango, NodeStatement, NodeStatementAssignment, NodeStatementList, NodeStatementSimple, NodeStatementSuite, NodeTerm};

pub struct Parser { pub token_stack: Vec<LexerResult>, pub action: HashMap<(i32, TokenType), ActionNode>, pub goto: HashMap<i32, GotoNode> }

impl Default for Parser { fn default() -> Parser { Parser { token_stack: Vec::new(), action: HashMap::new(), goto: HashMap::new() } } }

impl Parser {
    fn initialize(&mut self) {
{PARSER_INIT}
    }
     pub fn parse(&mut self) -> Box<Node> {
            self.initialize();
            let mut stack: Vec<i32> = Vec::new();
            stack.push(0);
            let mut node_stack: Vec<Box<Node>> = Vec::new();
            let token_stack = self.token_stack.clone();
            let mut iterator = token_stack.iter();
            let mut token = iterator.next().unwrap();
            loop {
                let mut state = *stack.last().unwrap();
                let action_node = self.action.get(&(state, token.token_type)).unwrap();
                println!("State: {}, TokenType: {:?} -> {:?} {}", state, token.token_type, action_node.action, action_node.value);
                match action_node.action {
                    ParserAction::Shift => {
                        if token.token_type == TokenType::Term { self.token_stack.push(token.clone()) }
                        stack.push(action_node.value);

                        match token.token_type {
                            TokenType::Term => {
                                node_stack.push(Box::new(NodeTerm { payload: token.clone() }));
                            }
                            TokenType::Identifier => {
                                node_stack.push(Box::new(NodeIdentifier { payload: token.clone() }));
                            }
                            _ => {}
                        }

                        token = iterator.next().unwrap();
                    }
                    ParserAction::Reduce => {
                        let goto_node = self.goto.get(&action_node.value).unwrap();
                        for _ in 0..goto_node.value { stack.pop(); }
                        state = *stack.last().unwrap();
                        let goto_action = self.action.get(&(state, goto_node.token_type)).unwrap();
                        stack.push(goto_action.value);
                        {
                            match action_node.value {
                                1 => {
                                    //NTS_STATEMENT_SUITE -> NTS_STATEMENT_LIST TS_NEWLINE
                                    let statement_list = node_stack.pop().unwrap();
                                    let node = NodeStatementSuite { statement_list: statement_list };
                                    node_stack.push(Box::new(node));
                                }
                                2 => {
                                    //NTS_STATEMENT_SUITE_FUNCTION -> NTS_STATEMENT_LIST_FUNCTION TS_NEWLINE
                                    let statement_limited = node_stack.pop().unwrap();
                                    let node = NodeStatementListFunction { statement_limited: statement_limited };
                                    node_stack.push(Box::new(node));
                                }
                                3 => {
                                    //NTS_STATEMENT_SUITE_CLASS -> NTS_STATEMENT_LIST_CLASS TS_NEWLINE
                                    let statement_list_class = node_stack.pop().unwrap();
                                    let node = NodeStatementSuiteClass { statement_list_class: statement_list_class };
                                    node_stack.push(Box::new(node));
                                }
                                4 => {
                                    //NTS_STATEMENT_LIST -> NTS_STATEMENT NTS_STATEMENT_LIST
                                    let statement_list = node_stack.pop().unwrap();
                                    let statement = node_stack.pop().unwrap();
                                    let node = NodeStatementListRecursive { statement: statement, statement_list: statement_list };
                                    node_stack.push(Box::new(node));
                                }
                                5 => {
                                    //NTS_STATEMENT_LIST -> NTS_STATEMENT
                                    let statement = node_stack.pop().unwrap();
                                    let node = NodeStatementList { statement: statement };
                                    node_stack.push(Box::new(node));
                                }
                                6 => {
                                    //NTS_STATEMENT_LIST_FUNCTION -> NTS_STATEMENT_LIMITED NTS_STATEMENT_LIST_FUNCTION
                                    let statement_list_function = node_stack.pop().unwrap();
                                    let statement_limited = node_stack.pop().unwrap();
                                    let node = NodeStatementListFunctionRecursive { statement_limited: statement_limited, statement_list_function: statement_list_function };
                                    node_stack.push(Box::new(node));
                                }
                                7 => {
                                    //NTS_STATEMENT_LIST_FUNCTION -> NTS_STATEMENT_LIMITED
                                    let statement_limited = node_stack.pop().unwrap();
                                    let node = NodeStatementListFunction { statement_limited: statement_limited };
                                    node_stack.push(Box::new(node));
                                }
                                8 => {
                                    //NTS_STATEMENT_LIST_CLASS -> NTS_STATEMENT_RESTRICTED NTS_STATEMENT_LIST_CLASS
                                    let statement_list_class = node_stack.pop().unwrap();
                                    let statement_restricted = node_stack.pop().unwrap();
                                    let node = NodeStatementListClassRecursive { statement_restricted: statement_restricted, statement_list_class: statement_list_class };
                                    node_stack.push(Box::new(node));
                                }
                                9 => {
                                    //NTS_STATEMENT_LIST_CLASS -> NTS_STATEMENT_RESTRICTED
                                    let statement_restricted = node_stack.pop().unwrap();
                                    let node = NodeStatementListClass { statement_restricted: statement_restricted };
                                    node_stack.push(Box::new(node));
                                }
                                10 | 11 | 12 | 13 => {
                                    //NTS_STATEMENT -> NTS_STATEMENT_SIMPLE
                                    //NTS_STATEMENT -> NTS_STATEMENT_COMPLEX
                                    //NTS_STATEMENT -> NTS_STATEMENT_FUNCTION
                                    //NTS_STATEMENT -> NTS_STATEMENT_CLASS
                                    let statement_x = node_stack.pop().unwrap();
                                    let node = NodeStatement { statement_x: statement_x };
                                    node_stack.push(Box::new(node));
                                }
                                14 | 15 => {
                                    //NTS_STATEMENT_LIMITED -> NTS_STATEMENT_SIMPLE
                                    //NTS_STATEMENT_LIMITED -> NTS_STATEMENT_COMPLEX
                                    let statement_x = node_stack.pop().unwrap();
                                    let node = NodeStatementLimited { statement_x: statement_x };
                                    node_stack.push(Box::new(node));
                                }
                                16 => {
                                    //NTS_STATEMENT_RESTRICTED -> NTS_STATEMENT_FUNCTION
                                    let statement_x = node_stack.pop().unwrap();
                                    let node = NodeStatementRestricted { statement_x: statement_x };
                                    node_stack.push(Box::new(node));
                                }
                                17 | 18 | 19 => {
                                    //NTS_STATEMENT_SIMPLE -> NTS_STATEMENT_EXPRESSION
                                    //NTS_STATEMENT_SIMPLE -> NTS_STATEMENT_ASSIGNMENT
                                    //NTS_STATEMENT_SIMPLE -> NTS_STATEMENT_CONDITIONAL
                                    let statement_x = node_stack.pop().unwrap();
                                    let node = NodeStatementSimple { statement_x: statement_x };
                                    node_stack.push(Box::new(node));
                                }
                                20 => {
                                    //NTS_STATEMENT_COMPLEX -> NTS_STATEMENT_LOOP
                                    let statement_x = node_stack.pop().unwrap();
                                    let node = NodeStatementComplex { statement_x: statement_x };
                                    node_stack.push(Box::new(node));
                                }
                                21 => {
                                    //NTS_STATEMENT_FUNCTION -> TS_AT TS_IDENTIFIER TS_COLON NTS_FUNCTION_PARAMS TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
                                    let statement_suite_function = node_stack.pop().unwrap();
                                    let function_params = node_stack.pop().unwrap();
                                    let identifier = node_stack.pop().unwrap();
                                    let node = NodeStatementFunction { identifier: identifier, function_params: function_params, statement_suite_function: statement_suite_function };
                                    node_stack.push(Box::new(node));
                                }
                                22 => {
                                    //NTS_FUNCTION_PARAMS -> NTS_FUNCTION_PARAMS TS_COMMA TS_IDENTIFIER
                                    let identifier = node_stack.pop().unwrap();
                                    let function_params = node_stack.pop().unwrap();
                                    let node = NodeFunctionParamsRecursive { function_params: function_params, identifier: identifier };
                                    node_stack.push(Box::new(node));
                                }
                                23 => {
                                    //NTS_FUNCTION_PARAMS -> TS_IDENTIFIER
                                    let identifier = node_stack.pop().unwrap();
                                    let node = NodeFunctionParams { identifier: identifier };
                                    node_stack.push(Box::new(node));
                                }
                                24 => {
                                    //NTS_STATEMENT_CLASS -> TS_AT TS_IDENTIFIER TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_CLASS TS_RIGHT_CURLY_BRACE
                                    let statement_suite_class = node_stack.pop().unwrap();
                                    let identifier = node_stack.pop().unwrap();
                                    let node = NodeStatementClass { identifier: identifier, statement_suite_class: statement_suite_class };
                                    node_stack.push(Box::new(node));
                                }
                                25 => {
                                    //NTS_STATEMENT_EXPRESSION -> NTS_STATEMENT_EXPRESSION_2 NTS_STATEMENT_EXPRESSION_P
                                    let statement_expression_p = node_stack.pop().unwrap();
                                    let statement_expression_2 = node_stack.pop().unwrap();
                                    let node = NodeStatementExpressionRecursive { statement_expression_2: statement_expression_2, statement_expression_p: statement_expression_p };
                                    node_stack.push(Box::new(node));
                                }
                                26 => {
                                    //NTS_STATEMENT_EXPRESSION -> NTS_STATEMENT_EXPRESSION_2
                                    let statement_expression_2 = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression { statement_expression_2: statement_expression_2 };
                                    node_stack.push(Box::new(node));
                                }
                                27 => {
                                    //NTS_STATEMENT_EXPRESSION_P -> TS_ADD NTS_STATEMENT_EXPRESSION
                                    let statement_expression = node_stack.pop().unwrap();
                                    let node = NodeStatementExpressionP { statement_expression: statement_expression, operator: TokenType::Add };
                                    node_stack.push(Box::new(node));
                                }
                                28 => {
                                    //NTS_STATEMENT_EXPRESSION_P -> TS_SUBTRACT NTS_STATEMENT_EXPRESSION
                                    let statement_expression = node_stack.pop().unwrap();
                                    let node = NodeStatementExpressionP { statement_expression: statement_expression, operator: TokenType::Subtract };
                                    node_stack.push(Box::new(node));
                                }
                                29 => {
                                    //NTS_STATEMENT_EXPRESSION_2 -> NTS_STATEMENT_EXPRESSION_3 NTS_STATEMENT_EXPRESSION_2P
                                    let statement_expression_2p = node_stack.pop().unwrap();
                                    let statement_expression_3 = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression2Recursive { statement_expression_3: statement_expression_3, statement_expression_2p: statement_expression_2p };
                                    node_stack.push(Box::new(node));
                                }
                                30 => {
                                    //NTS_STATEMENT_EXPRESSION_2 -> NTS_STATEMENT_EXPRESSION_3
                                    let statement_expression_3 = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression2 { statement_expression_3: statement_expression_3 };
                                    node_stack.push(Box::new(node));
                                }
                                31 => {
                                    //NTS_STATEMENT_EXPRESSION_2P -> TS_MULTIPLY NTS_STATEMENT_EXPRESSION_2
                                    let statement_expression_2 = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression2p { statement_expression_2: statement_expression_2 };
                                    node_stack.push(Box::new(node));
                                }
                                32 => {
                                    //NTS_STATEMENT_EXPRESSION_2P -> TS_DIVIDE NTS_STATEMENT_EXPRESSION_2
                                    let statement_expression_2 = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression2p { statement_expression_2: statement_expression_2 };
                                    node_stack.push(Box::new(node));
                                }
                                33 => {
                                    //NTS_STATEMENT_EXPRESSION_2P -> TS_MODULO NTS_STATEMENT_EXPRESSION_2
                                    let statement_expression_2 = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression2p { statement_expression_2: statement_expression_2 };
                                    node_stack.push(Box::new(node));
                                }
                                34 => {
                                    //NTS_STATEMENT_EXPRESSION_3 -> TS_TERM
                                    let term = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression3 { term: term };
                                    node_stack.push(Box::new(node));
                                }
                                35 => {
                                    //NTS_STATEMENT_EXPRESSION_3 -> TS_LEFT_PARENTHESIS NTS_STATEMENT_EXPRESSION TS_RIGHT_PARENTHESIS
                                    let statement_expression = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression3Paren { statement_expression: statement_expression };
                                    node_stack.push(Box::new(node));
                                }
                                36 => {
                                    //NTS_STATEMENT_EXPRESSION_3 -> TS_SUBTRACT NTS_STATEMENT_EXPRESSION_3
                                    let statement_expression_3 = node_stack.pop().unwrap();
                                    let node = NodeStatementExpression3Negation { statement_expression_3: statement_expression_3 };
                                    node_stack.push(Box::new(node));
                                }
                                37 => {
                                    //NTS_STATEMENT_ASSIGNMENT -> TS_IDENTIFIER TS_EQUALS NTS_STATEMENT_EXPRESSION
                                    let statement_expression = node_stack.pop().unwrap();
                                    let identifier = node_stack.pop().unwrap();
                                    let node = NodeStatementAssignment { identifier: identifier, statement_expression: statement_expression };
                                    node_stack.push(Box::new(node));
                                }
                                38 => {
                                    //NTS_STATEMENT_CONDITIONAL -> TS_IF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
                                    let statement_suite_function = node_stack.pop().unwrap();
                                    let conditional_expression = node_stack.pop().unwrap();
                                    let node = NodeStatementConditional { conditional_expression: conditional_expression, statement_suite_function: statement_suite_function };
                                    node_stack.push(Box::new(node));
                                }
                                39 => {
                                    //NTS_STATEMENT_CONDITIONAL -> TS_IF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE NTS_STATEMENT_CONDITIONAL_2
                                    let statement_conditional_2 = node_stack.pop().unwrap();
                                    let statement_suite_function = node_stack.pop().unwrap();
                                    let conditional_expression = node_stack.pop().unwrap();
                                    let node = NodeStatementConditionalW2 { conditional_expression: conditional_expression, statement_suite_function: statement_suite_function, statement_conditional_2: statement_conditional_2 };
                                    node_stack.push(Box::new(node));
                                }
                                40 => {
                                    //NTS_STATEMENT_CONDITIONAL -> TS_IF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE NTS_STATEMENT_CONDITIONAL_3
                                    let statement_conditional_3 = node_stack.pop().unwrap();
                                    let statement_suite_function = node_stack.pop().unwrap();
                                    let conditional_expression = node_stack.pop().unwrap();
                                    let node = NodeStatementConditionalW3 { conditional_expression: conditional_expression, statement_suite_function: statement_suite_function, statement_conditional_3: statement_conditional_3 };
                                    node_stack.push(Box::new(node));
                                }
                                41 => {
                                    //NTS_STATEMENT_CONDITIONAL_2 -> NTS_STATEMENT_CONDITIONAL_2 TS_ELIF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
                                    let statement_suite_function = node_stack.pop().unwrap();
                                    let conditional_expression = node_stack.pop().unwrap();
                                    let statement_conditional_2 = node_stack.pop().unwrap();
                                    let node = NodeStatementConditional2Recursive { statement_conditional_2: statement_conditional_2, conditional_expression: conditional_expression, statement_suite_function: statement_suite_function };
                                    node_stack.push(Box::new(node));
                                }
                                42 => {
                                    //NTS_STATEMENT_CONDITIONAL_2 -> TS_ELIF NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE NTS_STATEMENT_CONDITIONAL_3
                                    let statement_conditional_3 = node_stack.pop().unwrap();
                                    let statement_suite_function = node_stack.pop().unwrap();
                                    let conditional_expression = node_stack.pop().unwrap();
                                    let node = NodeStatementConditional2 { conditional_expression: conditional_expression, statement_suite_function: statement_suite_function, statement_conditional_3: statement_conditional_3 };
                                    node_stack.push(Box::new(node));
                                }
                                43 => {
                                    //NTS_STATEMENT_CONDITIONAL_3 -> TS_ELSE TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
                                    let statement_suite_function = node_stack.pop().unwrap();
                                    let node = NodeStatementConditional3 { statement_suite_function: statement_suite_function };
                                    node_stack.push(Box::new(node));
                                }
                                44 | 45 => {
                                    //NTS_CONDITIONAL_EXPRESSION -> TS_TERM NTS_COMPARISON_OPERATOR TS_TERM
                                    let term2 = node_stack.pop().unwrap();
                                    let comparison_operator = node_stack.pop().unwrap();
                                    let term1 = node_stack.pop().unwrap();
                                    let node = NodeConditionalExpression { term1: term1, comparison_operator: comparison_operator, term2: term2 };
                                    node_stack.push(Box::new(node));
                                }
                                45 => {
                                    //NTS_CONDITIONAL_EXPRESSION -> NTS_COMPARISON_OPERATOR_UNARY TS_TERM
                                    let term = node_stack.pop().unwrap();
                                    let comparison_operator_unary = node_stack.pop().unwrap();
                                    let node = NodeConditionalExpressionUnary { comparison_operator_unary: comparison_operator_unary, term: term };
                                    node_stack.push(Box::new(node));
                                }
                                46 => {
                                    //NTS_COMPARISON_OPERATOR -> TS_LESS_THAN
                                }
                                47 => {
                                    //NTS_COMPARISON_OPERATOR -> TS_LESS_THAN_EQUALS
                                }
                                48 => {
                                    //NTS_COMPARISON_OPERATOR -> TS_GREATER_THAN
                                }
                                49 => {
                                    //NTS_COMPARISON_OPERATOR -> TS_GREATER_THAN_EQUALS
                                }
                                50 => {
                                    //NTS_COMPARISON_OPERATOR -> TS_DOUBLE_EQUALS
                                }
                                51 => {
                                    //NTS_COMPARISON_OPERATOR -> TS_TRIPLE_EQUALS
                                }
                                52 => {
                                    //NTS_COMPARISON_OPERATOR_UNARY -> TS_NOT
                                }
                                53 => {
                                    //NTS_STATEMENT_LOOP -> NTS_STATEMENT_LOOP_FOR
                                }
                                54 => {
                                    //NTS_STATEMENT_LOOP -> NTS_STATEMENT_LOOP_WHILE
                                }
                                55 => {
                                    //NTS_STATEMENT_LOOP_FOR -> TS_FOR TS_IDENTIFIER TS_COLON TS_TERM TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
                                }
                                56 => {
                                    //NTS_STATEMENT_LOOP_FOR -> TS_FOR TS_IDENTIFIER TS_COLON TS_TERM TS_ELLIPSIS TS_TERM TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
                                }
                                57 => {
                                    //NTS_STATEMENT_LOOP_WHILE -> TS_WHILE NTS_CONDITIONAL_EXPRESSION TS_LEFT_CURLY_BRACE NTS_STATEMENT_SUITE_FUNCTION TS_RIGHT_CURLY_BRACE
                                }
                                _ => {
                                    //exhaustive
                                }
                                {NODE_SELECTION_INIT}
                            }
                        }
                    }
                    ParserAction::Accept => {
                        println!("Parse Accepted!");
                        return Box::from(NodeMango { statement_suite: node_stack.pop().unwrap() });
                    }
                    _ => {
                        println!("Parse Error!");
                        return Box::from(NodeMango { statement_suite: node_stack.pop().unwrap() });
                    }
                }
            }
        }
    }