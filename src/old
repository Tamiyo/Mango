        match instruction {
            Instruction::Constant(index) => {
                let constant = self.module.constants.get(index).clone();
                match constant {
                    Constant::Number(n) => self.push(Value::Number(Into::<f64>::into(n))),
                    Constant::String(sym) => self.push(Value::String(sym)),
                    Constant::Function(_) => (),
                    Constant::Class(_) => (),
                };
            }
            Instruction::True => self.stack.push(Value::Boolean(true)),
            Instruction::False => self.stack.push(Value::Boolean(false)),
            Instruction::None => self.stack.push(Value::None),
            Instruction::Add => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::from(n1 + n2)),
                (Value::String(n1), Value::String(n2)) => {
                    let mut str1 = self
                        .module
                        .strings
                        .resolve(n2)
                        .expect("Expected a &str")
                        .to_string();
                    let str2 = self.module.strings.resolve(n1).expect("Expected a &str");
                    str1.push_str(str2);

                    let sym = self.module.get_or_intern(&str1.as_str());
                    self.push(Value::String(sym))
                }
                (other, Value::String(n1)) => {
                    let mut str1 = self
                        .module
                        .strings
                        .resolve(n1)
                        .expect("Expected a &str")
                        .to_string();
                    str1.push_str(self.value_to_string(&other, false)?.as_str());

                    let sym = self.module.get_or_intern(&str1.as_str());
                    self.push(Value::String(sym))
                }
                (Value::Array(e2), Value::Array(e1)) => {
                    let v = [&e1[..], &e2[..]].concat();
                    self.push(Value::Array(v));
                }
                (n1, n2) => panic!(format!("Add not implemented for '{:?}' and '{:?}'", n1, n2)),
            },
            Instruction::Subtract => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::from(n2 - n1)),
                (n1, n2) => panic!(format!(
                    "Subtract not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::Negate => match self.pop()? {
                Value::Number(n) => self.push(Value::from(-1.0 * n)),
                n => panic!(format!("Negate not implemented for '{:?}''", n)),
            },
            Instruction::Multiply => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::from(n2 * n1)),
                (n1, n2) => panic!(format!(
                    "Multiply not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::Divide => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::from(n2 / n1)),
                (n1, n2) => panic!(format!(
                    "Divide not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::Modulo => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::from(n2 % n1)),
                (n1, n2) => panic!(format!(
                    "Modulo not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::Pow => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::from(f64::powf(
                    Into::<f64>::into(n2),
                    Into::<f64>::into(n1),
                ))),
                (n1, n2) => panic!(format!("Pow not implemented for '{:?}' and '{:?}'", n1, n2)),
            },
            Instruction::Not => match self.pop()? {
                Value::Boolean(b) => self.push(Value::Boolean(!b)),
                n1 => panic!(format!("Not not implemented for '{:?}'", n1)),
            },
            Instruction::NotEqual => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => {
                    let res = n2 - n1;
                    let nabs = if res < 0.0 { res * -1.0 } else { res };
                    self.push(Value::Boolean(nabs > std::f64::EPSILON))
                }
                (n1, n2) => panic!(format!(
                    "NotEqual not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::EqualEqual => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => {
                    self.push(Value::Boolean((n2 - n1).abs() < std::f64::EPSILON))
                }
                (Value::Array(a1), Value::Array(a2)) => self.push(Value::Boolean(a1 == a2)),
                (_, _) => self.push(Value::Boolean(false)),
            },
            Instruction::Greater => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::Boolean(n2 > n1)),
                (n1, n2) => panic!(format!(
                    "Greater not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::GreaterEqual => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::Boolean(n2 >= n1)),
                (n1, n2) => panic!(format!(
                    "GreaterEqual not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::Less => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::Boolean(n2 < n1)),
                (n1, n2) => panic!(format!(
                    "Less not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::LessEqual => match (self.pop()?, self.pop()?) {
                (Value::Number(n1), Value::Number(n2)) => self.push(Value::Boolean(n2 <= n1)),
                (n1, n2) => panic!(format!(
                    "LessEqual not implemented for '{:?}' and '{:?}'",
                    n1, n2
                )),
            },
            Instruction::JumpIfTrue(to) => {
                if let Value::Boolean(true) = self.peek()? {
                    self.current_frame_mut().ip = to;
                }
            }
            Instruction::JumpIfFalse(to) => {
                if let Value::Boolean(false) = self.peek()? {
                    self.current_frame_mut().ip = to;
                }
            }
            Instruction::Jump(to) => {
                self.current_frame_mut().ip = to;
            }
            Instruction::GetGlobal(index) => {
                if let Constant::String(key) = self.module.constants.get(index) {
                    if let Some(constant) = self.globals.get(key) {
                        self.push(*constant);
                    } else {
                        return Err(RuntimeError::UndefinedVariable);
                    }
                } else {
                    return Err(RuntimeError::ExpectedStringConstant);
                }
            }
            Instruction::GetLocal(index) => {
                let index = self.current_frame().base_counter + index;
                self.push(self.stack[index]);
            }
            Instruction::SetGlobal(index) => {
                if let Constant::String(key) = self.module.constants.get(index) {
                    let _key = key.clone();
                    let value = self.pop()?;
                    self.globals.insert(_key, value);
                } else {
                    panic!("Expected String Constant!");
                }
            }
            Instruction::SetLocal(index) => {
                let index = self.current_frame().base_counter + index;
                let value = self.peek()?.clone();
                self.stack[index] = *value;
            }
            Instruction::Call(arity) => {
                let a = arity;
                self.call(a)?;
            }
            Instruction::Function(index) => {
                let module = &self.module;
                if let Constant::Function(function) = module.constants.get(index) {
                    let constant = Value::Function(*function);
                    // let constant = Value::Function(manage(function.clone()));
                    self.push(constant);
                }
            }
            Instruction::Class(index) => {
                if let Constant::Class(class) = self.module.constants.get(index) {
                    let class = VMClass {
                        name: class.name.clone(),
                        methods: HashMap::new(),
                    };
                    self.push(Value::Class(RefCell::new(class)));
                } else {
                    return Err(RuntimeError::UnexpectedConstant);
                }
            }
            Instruction::GetProperty(index) => {
                if let Value::Instance(instance) = self.pop()? {
                    if let Constant::String(property) = self.module.get_constant(index) {
                        if let Some(value) = instance.borrow().fields.get(property) {
                            self.push(value.clone());
                        } else {
                            return Err(RuntimeError::UndefinedProperty);
                        }
                    } else {
                        return Err(RuntimeError::ExpectedInstance);
                    }
                }
            }
            Instruction::SetProperty(index) => {
                if let Constant::String(property) = self.module.get_constant(index) {
                    if let Value::Instance(instance) = self.peek_n(1)? {
                        instance
                            .borrow_mut()
                            .fields
                            .insert(property.clone(), self.peek()?.clone());

                        let value = self.pop()?;
                        self.pop()?;
                        self.push(value);
                    } else {
                        return Err(RuntimeError::UnexpectedValue);
                    }
                } else {
                    return Err(RuntimeError::UnexpectedConstant);
                }
            }
            Instruction::Method => {
                // let peek = self.peek()?.clone();
                // let next_mut = self.peek_n_mut(1)?;

                // match next_mut {
                //     Value::Class(class) => match &peek {
                //         Value::Function(function) => {
                //             let name = function.name;
                //             class.methods.insert(name, peek.clone());
                //             self.pop()?;
                //         }
                //         _ => return Err(RuntimeError::ExpectedCallee),
                //     },
                //     _ => return Err(RuntimeError::ExpectedClass),
                // }
                if let Value::Function(function) = self.peek()? {
                    if let Value::Class(class) = self.peek_n(1)? {
                        let name = function.name;
                        class
                            .borrow_mut()
                            .methods
                            .insert(name, Value::Function(function.clone()));
                        self.pop()?;
                    } else {
                        return Err(RuntimeError::ExpectedClass);
                    }
                } else {
                    return Err(RuntimeError::ExpectedCallee);
                }
            }
            Instruction::Pop => {
                self.pop()?;
            }
            Instruction::List(length) => {
                let mut elements = Vec::new();
                for _ in 0..length {
                    elements.push(self.pop()?);
                }
                elements.reverse();
                self.stack.push(Value::Array(elements))
            }
            Instruction::Slice => {
                let step = match self.pop()? {
                    Value::Number(n) => Some(n),
                    Value::None => None,
                    _ => return Err(RuntimeError::ExpectedNumber),
                };

                let stop = match self.pop()? {
                    Value::Number(n) => Some(n),
                    Value::None => None,
                    _ => return Err(RuntimeError::ExpectedNumber),
                };

                let start = match self.pop()? {
                    Value::Number(n) => Some(n),
                    Value::None => None,
                    _ => return Err(RuntimeError::ExpectedNumber),
                };

                let mut arr: Vec<Value> = match self.pop()? {
                    Value::Array(elements) => elements,
                    _ => return Err(RuntimeError::ExpectedArray),
                };

                let mut res: Vec<Value> = vec![];

                let a = match start {
                    Some(t) => Into::<f64>::into(t) as usize,
                    None => 0,
                };

                let b = match stop {
                    Some(t) => Into::<f64>::into(t) as usize,
                    None => arr.len(),
                };

                let c = match step {
                    Some(t) => Into::<f64>::into(t) as isize,
                    None => 1,
                };

                if c > 0 {
                    for i in (a..b).step_by(c as usize) {
                        res.push(arr[i].clone());
                    }
                } else {
                    arr.reverse();
                    for i in (a..b).step_by(-c as usize) {
                        res.push(arr[i].clone());
                    }
                };
                self.push(Value::Array(res));
            }
            Instruction::Range => {
                let step = match self.pop()? {
                    Value::Number(n) => Some(n),
                    Value::None => None,
                    _ => return Err(RuntimeError::ExpectedNumber),
                };

                let stop = match self.pop()? {
                    Value::Number(n) => Into::<f64>::into(n) as isize,
                    _ => return Err(RuntimeError::ExpectedNumber),
                };

                let start = match self.pop()? {
                    Value::Number(n) => Into::<f64>::into(n) as isize,
                    _ => return Err(RuntimeError::ExpectedNumber),
                };

                let mut res: Vec<Value> = vec![];

                let c = match step {
                    Some(t) => Into::<f64>::into(t) as isize,
                    None => 1,
                };

                if c > 0 {
                    for i in (start..stop).step_by(c as usize) {
                        res.push(Value::from(i as f64));
                    }
                } else {
                    for i in (start..stop).step_by(-c as usize) {
                        res.push(Value::from(i as f64));
                    }
                    res.reverse();
                };
                self.push(Value::Array(res));
            }
            Instruction::Index => {
                let index: isize = match self.pop()? {
                    Value::Number(n) => Into::<f64>::into(n) as isize,
                    _ => return Err(RuntimeError::ExpectedNumber),
                };

                match self.pop()? {
                    Value::Array(elements) => {
                        if index < 0 {
                            if (-index as usize) >= elements.len() {
                                return Err(RuntimeError::IndexOutOfBounds);
                            } else {
                                let len = elements.len();
                                self.push(elements[len - (-index as usize)].clone());
                            }
                        } else {
                            if (index as usize) >= elements.len() {
                                return Err(RuntimeError::IndexOutOfBounds);
                            } else {
                                self.push(elements[index as usize].clone());
                            }
                        }
                    }
                    _ => return Err(RuntimeError::ExpectedNumber),
                };
            }
            Instruction::Print(ref n) => {
                let no_elem = *n;
                let mut elements = self.pop_n(no_elem)?;
                elements.reverse();
                for e in elements {
                    self.print_value(e)?;
                    print!(" ");
                }
                println!("");
            }
            Instruction::Return => {
                let res = self.pop();
                let frame = self
                    .frames
                    .pop()
                    .ok_or_else(|| RuntimeError::CallFrameEmpty)?;

                self.stack.split_off(frame.base_counter);

                if self.frames.is_empty() {
                    return Ok(InterpreterResult::Done);
                }
                self.push(res?);
            }
        };